"use strict";(globalThis.webpackChunkdocumentation_docs_markdown=globalThis.webpackChunkdocumentation_docs_markdown||[]).push([[9699],{5822:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>d,contentTitle:()=>o,default:()=>v,frontMatter:()=>s,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"architecture-and-patterns/event-driven-architecture","title":"Event-Driven Architecture","description":"This file covers event-driven architecture patterns, implementation strategies, and best practices.","source":"@site/docs/architecture-and-patterns/event-driven-architecture.md","sourceDirName":"architecture-and-patterns","slug":"/architecture-and-patterns/event-driven-architecture","permalink":"/documentation-docs-markdown/docs/architecture-and-patterns/event-driven-architecture","draft":false,"unlisted":false,"editUrl":"https://github.com/EndToEndLabCR/docs/architecture-and-patterns/event-driven-architecture.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Design Patterns in Python","permalink":"/documentation-docs-markdown/docs/architecture-and-patterns/design-patterns-in-python"},"next":{"title":"Microservices Architecture","permalink":"/documentation-docs-markdown/docs/architecture-and-patterns/microservices-architecture"}}');var a=t(4848),i=t(8453);const s={},o="Event-Driven Architecture",d={},c=[{value:"Core Concepts",id:"core-concepts",level:2},{value:"Events vs Messages",id:"events-vs-messages",level:3},{value:"Event Types",id:"event-types",level:3},{value:"Event Sourcing",id:"event-sourcing",level:2},{value:"Implementation",id:"implementation",level:3},{value:"CQRS (Command Query Responsibility Segregation)",id:"cqrs-command-query-responsibility-segregation",level:2},{value:"Command Side",id:"command-side",level:3},{value:"Query Side",id:"query-side",level:3},{value:"Event Streaming with Kafka",id:"event-streaming-with-kafka",level:2},{value:"Producer Configuration",id:"producer-configuration",level:3},{value:"Consumer Configuration",id:"consumer-configuration",level:3},{value:"Saga Pattern for Process Management",id:"saga-pattern-for-process-management",level:2},{value:"Orchestration-based Saga",id:"orchestration-based-saga",level:3},{value:"Choreography-based Saga",id:"choreography-based-saga",level:3},{value:"Event Store Snapshots",id:"event-store-snapshots",level:2},{value:"Snapshot Implementation",id:"snapshot-implementation",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"Event Design",id:"event-design",level:3},{value:"Performance Considerations",id:"performance-considerations",level:3},{value:"Error Handling",id:"error-handling",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"event-driven-architecture",children:"Event-Driven Architecture"})}),"\n",(0,a.jsx)(n.p,{children:"This file covers event-driven architecture patterns, implementation strategies, and best practices."}),"\n",(0,a.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,a.jsx)(n.h3,{id:"events-vs-messages",children:"Events vs Messages"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Events"}),": Something that happened in the past (immutable)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Commands"}),": Instructions to do something (imperative)"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Queries"}),": Requests for information (interrogative)"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"event-types",children:"Event Types"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Domain Event\npublic class OrderCreatedEvent extends DomainEvent {\n    private final String orderId;\n    private final String customerId;\n    private final BigDecimal totalAmount;\n    private final LocalDateTime createdAt;\n\n    public OrderCreatedEvent(String orderId, String customerId, BigDecimal totalAmount) {\n        super();\n        this.orderId = orderId;\n        this.customerId = customerId;\n        this.totalAmount = totalAmount;\n        this.createdAt = LocalDateTime.now();\n    }\n\n    // Getters\n}\n\n// Integration Event\npublic class CustomerRegisteredEvent {\n    private final String customerId;\n    private final String email;\n    private final String firstName;\n    private final String lastName;\n\n    // Constructor and getters\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"event-sourcing",children:"Event Sourcing"}),"\n",(0,a.jsx)(n.h3,{id:"implementation",children:"Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Event Store\n@Entity\n@Table(name = "event_store")\npublic class EventStoreEntry {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    private Long id;\n\n    @Column(name = "stream_id")\n    private String streamId;\n\n    @Column(name = "event_type")\n    private String eventType;\n\n    @Column(name = "event_data", columnDefinition = "TEXT")\n    private String eventData;\n\n    @Column(name = "event_version")\n    private Long version;\n\n    @Column(name = "timestamp")\n    private LocalDateTime timestamp;\n\n    // Constructors, getters, setters\n}\n\n// Event Store Repository\n@Repository\npublic class EventStore {\n    private final EventStoreRepository repository;\n    private final ObjectMapper objectMapper;\n\n    public void saveEvents(String streamId, List<DomainEvent> events, Long expectedVersion) {\n        Long currentVersion = getLastVersion(streamId);\n\n        if (!Objects.equals(currentVersion, expectedVersion)) {\n            throw new ConcurrencyException("Stream has been modified");\n        }\n\n        for (int i = 0; i < events.size(); i++) {\n            DomainEvent event = events.get(i);\n            EventStoreEntry entry = new EventStoreEntry();\n            entry.setStreamId(streamId);\n            entry.setEventType(event.getClass().getSimpleName());\n            entry.setEventData(serialize(event));\n            entry.setVersion(currentVersion + i + 1);\n            entry.setTimestamp(LocalDateTime.now());\n\n            repository.save(entry);\n        }\n    }\n\n    public List<DomainEvent> getEvents(String streamId) {\n        List<EventStoreEntry> entries = repository.findByStreamIdOrderByVersion(streamId);\n\n        return entries.stream()\n            .map(this::deserialize)\n            .collect(Collectors.toList());\n    }\n\n    public List<DomainEvent> getEvents(String streamId, Long fromVersion) {\n        List<EventStoreEntry> entries = repository\n            .findByStreamIdAndVersionGreaterThanOrderByVersion(streamId, fromVersion);\n\n        return entries.stream()\n            .map(this::deserialize)\n            .collect(Collectors.toList());\n    }\n}\n\n// Aggregate Root with Event Sourcing\npublic abstract class AggregateRoot {\n    private String id;\n    private Long version;\n    private final List<DomainEvent> uncommittedEvents = new ArrayList<>();\n\n    protected void applyEvent(DomainEvent event) {\n        applyChange(event, true);\n    }\n\n    public void markEventsAsCommitted() {\n        uncommittedEvents.clear();\n    }\n\n    public void loadFromHistory(List<DomainEvent> history) {\n        for (DomainEvent event : history) {\n            applyChange(event, false);\n            version++;\n        }\n    }\n\n    private void applyChange(DomainEvent event, boolean isNew) {\n        // Apply event to current state using reflection or visitor pattern\n        apply(event);\n\n        if (isNew) {\n            uncommittedEvents.add(event);\n        }\n    }\n\n    protected abstract void apply(DomainEvent event);\n\n    public List<DomainEvent> getUncommittedEvents() {\n        return Collections.unmodifiableList(uncommittedEvents);\n    }\n\n    // Getters and setters\n}\n\n// Order Aggregate\npublic class Order extends AggregateRoot {\n    private OrderStatus status;\n    private String customerId;\n    private List<OrderItem> items;\n    private BigDecimal totalAmount;\n\n    public Order() {\n        // Default constructor for framework\n    }\n\n    public Order(String customerId, List<OrderItem> items) {\n        setId(UUID.randomUUID().toString());\n        this.customerId = customerId;\n        this.items = new ArrayList<>(items);\n        this.status = OrderStatus.DRAFT;\n        this.totalAmount = calculateTotal();\n\n        applyEvent(new OrderCreatedEvent(getId(), customerId, totalAmount));\n    }\n\n    public void confirm() {\n        if (status != OrderStatus.DRAFT) {\n            throw new IllegalStateException("Only draft orders can be confirmed");\n        }\n\n        this.status = OrderStatus.CONFIRMED;\n        applyEvent(new OrderConfirmedEvent(getId()));\n    }\n\n    @Override\n    protected void apply(DomainEvent event) {\n        if (event instanceof OrderCreatedEvent) {\n            apply((OrderCreatedEvent) event);\n        } else if (event instanceof OrderConfirmedEvent) {\n            apply((OrderConfirmedEvent) event);\n        }\n        // Handle other events\n    }\n\n    private void apply(OrderCreatedEvent event) {\n        setId(event.getOrderId());\n        this.customerId = event.getCustomerId();\n        this.totalAmount = event.getTotalAmount();\n        this.status = OrderStatus.DRAFT;\n    }\n\n    private void apply(OrderConfirmedEvent event) {\n        this.status = OrderStatus.CONFIRMED;\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"cqrs-command-query-responsibility-segregation",children:"CQRS (Command Query Responsibility Segregation)"}),"\n",(0,a.jsx)(n.h3,{id:"command-side",children:"Command Side"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Commands\npublic interface Command {\n    String getAggregateId();\n}\n\npublic class CreateOrderCommand implements Command {\n    private final String orderId;\n    private final String customerId;\n    private final List<OrderItemData> items;\n\n    // Constructor and getters\n\n    @Override\n    public String getAggregateId() {\n        return orderId;\n    }\n}\n\n// Command Handlers\n@Component\npublic class OrderCommandHandler {\n    private final EventStore eventStore;\n\n    @CommandHandler\n    public void handle(CreateOrderCommand command) {\n        List<OrderItem> items = command.getItems().stream()\n            .map(data -> new OrderItem(data.getProductId(), data.getQuantity(), data.getPrice()))\n            .collect(Collectors.toList());\n\n        Order order = new Order(command.getCustomerId(), items);\n\n        eventStore.saveEvents(\n            order.getId(),\n            order.getUncommittedEvents(),\n            order.getVersion()\n        );\n\n        order.markEventsAsCommitted();\n    }\n\n    @CommandHandler\n    public void handle(ConfirmOrderCommand command) {\n        List<DomainEvent> events = eventStore.getEvents(command.getOrderId());\n        Order order = new Order();\n        order.loadFromHistory(events);\n\n        order.confirm();\n\n        eventStore.saveEvents(\n            order.getId(),\n            order.getUncommittedEvents(),\n            order.getVersion()\n        );\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h3,{id:"query-side",children:"Query Side"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'// Read Models\n@Entity\n@Table(name = "order_view")\npublic class OrderView {\n    @Id\n    private String orderId;\n    private String customerId;\n    private String customerName;\n    private BigDecimal totalAmount;\n    private String status;\n    private LocalDateTime createdAt;\n    private LocalDateTime confirmedAt;\n\n    // Constructors, getters, setters\n}\n\n// Projection Handlers (Event Handlers for Read Side)\n@Component\npublic class OrderProjectionHandler {\n    private final OrderViewRepository repository;\n\n    @EventHandler\n    public void on(OrderCreatedEvent event) {\n        OrderView view = new OrderView();\n        view.setOrderId(event.getOrderId());\n        view.setCustomerId(event.getCustomerId());\n        view.setTotalAmount(event.getTotalAmount());\n        view.setStatus("DRAFT");\n        view.setCreatedAt(event.getOccurredOn());\n\n        repository.save(view);\n    }\n\n    @EventHandler\n    public void on(OrderConfirmedEvent event) {\n        OrderView view = repository.findById(event.getOrderId())\n            .orElseThrow(() -> new IllegalStateException("Order view not found"));\n\n        view.setStatus("CONFIRMED");\n        view.setConfirmedAt(event.getOccurredOn());\n\n        repository.save(view);\n    }\n\n    @EventHandler\n    public void on(CustomerRegisteredEvent event) {\n        // Update customer name in all order views\n        List<OrderView> orders = repository.findByCustomerId(event.getCustomerId());\n        orders.forEach(order -> {\n            order.setCustomerName(event.getFirstName() + " " + event.getLastName());\n            repository.save(order);\n        });\n    }\n}\n\n// Query Handlers\n@Component\npublic class OrderQueryHandler {\n    private final OrderViewRepository repository;\n\n    public Optional<OrderView> findById(String orderId) {\n        return repository.findById(orderId);\n    }\n\n    public List<OrderView> findByCustomerId(String customerId) {\n        return repository.findByCustomerId(customerId);\n    }\n\n    public Page<OrderView> findByStatus(String status, Pageable pageable) {\n        return repository.findByStatus(status, pageable);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"event-streaming-with-kafka",children:"Event Streaming with Kafka"}),"\n",(0,a.jsx)(n.h3,{id:"producer-configuration",children:"Producer Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Configuration\npublic class KafkaProducerConfig {\n\n    @Bean\n    public ProducerFactory<String, Object> producerFactory() {\n        Map<String, Object> configProps = new HashMap<>();\n        configProps.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");\n        configProps.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class);\n        configProps.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, JsonSerializer.class);\n        configProps.put(ProducerConfig.ACKS_CONFIG, "all");\n        configProps.put(ProducerConfig.RETRIES_CONFIG, 3);\n        configProps.put(ProducerConfig.BATCH_SIZE_CONFIG, 16384);\n        configProps.put(ProducerConfig.LINGER_MS_CONFIG, 5);\n\n        return new DefaultKafkaProducerFactory<>(configProps);\n    }\n\n    @Bean\n    public KafkaTemplate<String, Object> kafkaTemplate() {\n        return new KafkaTemplate<>(producerFactory());\n    }\n}\n\n// Event Publisher\n@Component\npublic class EventPublisher {\n    private final KafkaTemplate<String, Object> kafkaTemplate;\n\n    public void publish(DomainEvent event) {\n        String topic = getTopicName(event);\n        String key = event.getAggregateId();\n\n        kafkaTemplate.send(topic, key, event)\n            .addCallback(\n                result -> log.info("Event published successfully: {}", event),\n                failure -> log.error("Failed to publish event: {}", event, failure)\n            );\n    }\n\n    private String getTopicName(DomainEvent event) {\n        return "events." + event.getClass().getSimpleName().toLowerCase();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"consumer-configuration",children:"Consumer Configuration"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Configuration\n@EnableKafka\npublic class KafkaConsumerConfig {\n\n    @Bean\n    public ConsumerFactory<String, Object> consumerFactory() {\n        Map<String, Object> props = new HashMap<>();\n        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, "localhost:9092");\n        props.put(ConsumerConfig.GROUP_ID_CONFIG, "order-service");\n        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer.class);\n        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, JsonDeserializer.class);\n        props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, "earliest");\n        props.put(JsonDeserializer.TRUSTED_PACKAGES, "*");\n\n        return new DefaultKafkaConsumerFactory<>(props);\n    }\n\n    @Bean\n    public ConcurrentKafkaListenerContainerFactory<String, Object> kafkaListenerContainerFactory() {\n        ConcurrentKafkaListenerContainerFactory<String, Object> factory =\n            new ConcurrentKafkaListenerContainerFactory<>();\n        factory.setConsumerFactory(consumerFactory());\n        factory.setConcurrency(3);\n        factory.setRetryTemplate(retryTemplate());\n        factory.setErrorHandler(new SeekToCurrentErrorHandler());\n\n        return factory;\n    }\n\n    @Bean\n    public RetryTemplate retryTemplate() {\n        RetryTemplate retryTemplate = new RetryTemplate();\n\n        FixedBackOffPolicy backOffPolicy = new FixedBackOffPolicy();\n        backOffPolicy.setBackOffPeriod(1000L);\n        retryTemplate.setBackOffPolicy(backOffPolicy);\n\n        SimpleRetryPolicy retryPolicy = new SimpleRetryPolicy();\n        retryPolicy.setMaxAttempts(3);\n        retryTemplate.setRetryPolicy(retryPolicy);\n\n        return retryTemplate;\n    }\n}\n\n// Event Listeners\n@Component\npublic class OrderEventListener {\n\n    @KafkaListener(topics = "events.customerwelcomed")\n    public void handleCustomerWelcomed(CustomerWelcomedEvent event) {\n        log.info("Customer welcomed: {}", event.getCustomerId());\n        // Send welcome email or perform other actions\n    }\n\n    @KafkaListener(topics = "events.inventoryreserved")\n    public void handleInventoryReserved(InventoryReservedEvent event) {\n        log.info("Inventory reserved for order: {}", event.getOrderId());\n        // Continue with order processing\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"saga-pattern-for-process-management",children:"Saga Pattern for Process Management"}),"\n",(0,a.jsx)(n.h3,{id:"orchestration-based-saga",children:"Orchestration-based Saga"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Component\npublic class OrderProcessSaga {\n    private final InventoryService inventoryService;\n    private final PaymentService paymentService;\n    private final NotificationService notificationService;\n\n    @SagaOrchestrationStart\n    public void processOrder(OrderCreatedEvent event) {\n        SagaTransaction saga = SagaTransaction.builder()\n            .step("reserve-inventory")\n                .action(() -> inventoryService.reserve(event.getOrderId()))\n                .compensation(() -> inventoryService.release(event.getOrderId()))\n            .step("process-payment")\n                .action(() -> paymentService.charge(event.getOrderId()))\n                .compensation(() -> paymentService.refund(event.getOrderId()))\n            .step("send-confirmation")\n                .action(() -> notificationService.sendConfirmation(event.getOrderId()))\n                .compensation(() -> notificationService.sendCancellation(event.getOrderId()))\n            .build();\n\n        saga.execute();\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h3,{id:"choreography-based-saga",children:"Choreography-based Saga"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:"// Each service handles its own compensation\n@Component\npublic class InventoryService {\n\n    @EventHandler\n    public void on(OrderCreatedEvent event) {\n        try {\n            reserve(event.getOrderId(), event.getItems());\n            eventPublisher.publish(new InventoryReservedEvent(event.getOrderId()));\n        } catch (InsufficientInventoryException e) {\n            eventPublisher.publish(new InventoryReservationFailedEvent(event.getOrderId(), e.getMessage()));\n        }\n    }\n\n    @EventHandler\n    public void on(OrderCancelledEvent event) {\n        release(event.getOrderId());\n        eventPublisher.publish(new InventoryReleasedEvent(event.getOrderId()));\n    }\n}\n\n@Component\npublic class PaymentService {\n\n    @EventHandler\n    public void on(InventoryReservedEvent event) {\n        try {\n            charge(event.getOrderId());\n            eventPublisher.publish(new PaymentProcessedEvent(event.getOrderId()));\n        } catch (PaymentException e) {\n            eventPublisher.publish(new PaymentFailedEvent(event.getOrderId(), e.getMessage()));\n            // Trigger compensation\n            eventPublisher.publish(new OrderCancelledEvent(event.getOrderId()));\n        }\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h2,{id:"event-store-snapshots",children:"Event Store Snapshots"}),"\n",(0,a.jsx)(n.h3,{id:"snapshot-implementation",children:"Snapshot Implementation"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-java",children:'@Entity\n@Table(name = "snapshots")\npublic class Snapshot {\n    @Id\n    private String aggregateId;\n\n    @Column(name = "aggregate_type")\n    private String aggregateType;\n\n    @Column(name = "data", columnDefinition = "TEXT")\n    private String data;\n\n    @Column(name = "version")\n    private Long version;\n\n    @Column(name = "timestamp")\n    private LocalDateTime timestamp;\n\n    // Constructors, getters, setters\n}\n\npublic class SnapshotStore {\n    private final SnapshotRepository repository;\n    private final ObjectMapper objectMapper;\n\n    public void saveSnapshot(AggregateRoot aggregate) {\n        Snapshot snapshot = new Snapshot();\n        snapshot.setAggregateId(aggregate.getId());\n        snapshot.setAggregateType(aggregate.getClass().getSimpleName());\n        snapshot.setData(serialize(aggregate));\n        snapshot.setVersion(aggregate.getVersion());\n        snapshot.setTimestamp(LocalDateTime.now());\n\n        repository.save(snapshot);\n    }\n\n    public <T extends AggregateRoot> Optional<T> loadSnapshot(String aggregateId, Class<T> aggregateType) {\n        return repository.findByAggregateIdAndAggregateType(aggregateId, aggregateType.getSimpleName())\n            .map(snapshot -> deserialize(snapshot.getData(), aggregateType));\n    }\n}\n\n// Loading with snapshots\npublic class AggregateRepository<T extends AggregateRoot> {\n    private final EventStore eventStore;\n    private final SnapshotStore snapshotStore;\n\n    public T load(String aggregateId, Class<T> aggregateType) {\n        // Try to load from snapshot first\n        Optional<T> snapshot = snapshotStore.loadSnapshot(aggregateId, aggregateType);\n\n        if (snapshot.isPresent()) {\n            T aggregate = snapshot.get();\n            // Load events after snapshot\n            List<DomainEvent> events = eventStore.getEvents(aggregateId, aggregate.getVersion());\n            aggregate.loadFromHistory(events);\n            return aggregate;\n        } else {\n            // Load all events\n            List<DomainEvent> events = eventStore.getEvents(aggregateId);\n            T aggregate = createInstance(aggregateType);\n            aggregate.loadFromHistory(events);\n            return aggregate;\n        }\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,a.jsx)(n.h3,{id:"event-design",children:"Event Design"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Immutable Events"}),": Events should never change"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Rich Events"}),": Include enough data to avoid querying"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Business Language"}),": Use domain terminology"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Versioning"}),": Plan for event schema evolution"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Snapshots"}),": For aggregates with many events"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Projections"}),": Pre-computed views for queries"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Caching"}),": Cache frequently accessed data"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Async Processing"}),": Handle events asynchronously when possible"]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"error-handling",children:"Error Handling"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Idempotency"}),": Handle duplicate events gracefully"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Dead Letter Queues"}),": For failed events"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Monitoring"}),": Track event processing metrics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Compensation"}),": Plan for failure scenarios"]}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Event-driven architecture enables scalable, resilient systems but requires careful design and operational practices."})]})}function v(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var r=t(6540);const a={},i=r.createContext(a);function s(e){const n=r.useContext(i);return r.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);